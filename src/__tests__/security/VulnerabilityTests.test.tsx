import { render, act } from '@testing-library/react';
import DOMPurify from 'dompurify';
import { LeadForm } from '@/components/leads/LeadForm';
import { CustomerForm } from '@/components/customers/CustomerForm';
import { LeadService } from '@/lib/services/LeadService';
import { CustomerService } from '@/lib/services/CustomerService';
import { UserService } from '@/lib/services/UserService';
import { useToast } from '@/components/ui/use-toast';

// Mock services
jest.mock('@/lib/services/LeadService');
jest.mock('@/lib/services/CustomerService');
jest.mock('@/lib/services/UserService');

// Mock useToast
jest.mock('@/components/ui/use-toast', () => ({
  useToast: jest.fn()
}));

describe('Security Vulnerability Tests', () => {
  const mockToast = {
    toast: jest.fn()
  };
  
  beforeEach(() => {
    jest.clearAllMocks();
    (useToast as jest.Mock).mockReturnValue(mockToast);
  });
  
  describe('Input Validation & Sanitization', () => {
    it('sanitizes HTML in text inputs', async () => {
      const maliciousInput = '<script>alert("xss")</script>Test Company';
      const sanitizedInput = DOMPurify.sanitize(maliciousInput);
      
      expect(sanitizedInput).not.toContain('<script>');
      expect(sanitizedInput).toContain('Test Company');
    });
    
    it('validates and sanitizes email addresses', () => {
      const testCases = [
        { input: 'test@example.com', valid: true },
        { input: 'invalid-email', valid: false },
        { input: '<script>@hack.com', valid: false },
        { input: 'test+alias@example.com', valid: true }
      ];
      
      testCases.forEach(({ input, valid }) => {
        const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        const sanitizedEmail = DOMPurify.sanitize(input);
        const isValid = emailRegex.test(sanitizedEmail);
        
        expect(isValid).toBe(valid);
      });
    });
    
    it('prevents SQL injection patterns', () => {
      const maliciousInputs = [
        "'; DROP TABLE users; --",
        "' OR '1'='1",
        "admin'--",
        "); DELETE FROM customers; --"
      ];
      
      maliciousInputs.forEach(input => {
        const sanitized = input.replace(/['";)(\\/]/g, '');
        expect(sanitized).not.toContain(';');
        expect(sanitized).not.toContain('--');
      });
    });
  });
  
  describe('XSS Prevention', () => {
    it('escapes HTML in lead form inputs', async () => {
      const maliciousData = {
        contact: {
          name: '<img src="x" onerror="alert(\'xss\')">',
          email: 'test@example.com',
          phone: '"><script>alert("xss")</script>'
        }
      };
      
      render(<LeadForm tenantId="test-tenant" />);
      
      // Verify that the LeadService sanitizes data before saving
      await act(async () => {
        const savedData = await new LeadService().createLead(maliciousData);
        expect(savedData).not.toContain('<script>');
        expect(savedData).not.toContain('onerror');
      });
    });
    
    it('sanitizes HTML in rich text fields', () => {
      const maliciousHtml = `
        <div>
          <script>alert('xss')</script>
          <p>Valid content</p>
          <img src="x" onerror="alert('xss')">
          <iframe src="malicious.html"></iframe>
        </div>
      `;
      
      const sanitizedHtml = DOMPurify.sanitize(maliciousHtml, {
        ALLOWED_TAGS: ['div', 'p'],
        ALLOWED_ATTR: []
      });
      
      expect(sanitizedHtml).not.toContain('<script>');
      expect(sanitizedHtml).not.toContain('onerror');
      expect(sanitizedHtml).not.toContain('<iframe>');
      expect(sanitizedHtml).toContain('<p>Valid content</p>');
    });
  });
  
  describe('CSRF Protection', () => {
    it('includes CSRF token in requests', async () => {
      const mockCsrfToken = 'test-csrf-token';
      document.cookie = `csrfToken=${mockCsrfToken}`;
      
      const leadService = new LeadService();
      await leadService.createLead({
        contact: {
          name: 'Test Lead',
          email: 'test@example.com'
        }
      });
      
      expect(LeadService.prototype.createLead).toHaveBeenCalledWith(
        expect.objectContaining({
          headers: expect.objectContaining({
            'X-CSRF-Token': mockCsrfToken
          })
        })
      );
    });
    
    it('validates CSRF token on form submission', async () => {
      const invalidCsrfToken = 'invalid-token';
      document.cookie = `csrfToken=${invalidCsrfToken}`;
      
      render(<CustomerForm tenantId="test-tenant" />);
      
      await act(async () => {
        const result = await new CustomerService().createCustomer({
          name: 'Test Customer',
          email: 'test@example.com'
        });
        
        expect(result).rejects.toThrow('Invalid CSRF token');
      });
    });
  });
  
  describe('Rate Limiting', () => {
    it('enforces rate limits on authentication attempts', async () => {
      const userService = new UserService();
      const attempts = [];
      
      // Attempt multiple sign-ins in quick succession
      for (let i = 0; i < 5; i++) {
        attempts.push(
          userService.signIn('test@example.com', 'password')
        );
      }
      
      await expect(Promise.all(attempts)).rejects.toThrow('Too many requests');
    });
    
    it('enforces rate limits on password reset requests', async () => {
      const userService = new UserService();
      const attempts = [];
      
      // Attempt multiple password resets in quick succession
      for (let i = 0; i < 3; i++) {
        attempts.push(
          userService.sendPasswordResetEmail('test@example.com')
        );
      }
      
      await expect(Promise.all(attempts)).rejects.toThrow('Too many requests');
    });
  });
  
  describe('Data Validation', () => {
    it('validates phone numbers', () => {
      const testCases = [
        { input: '+1-555-123-4567', valid: true },
        { input: '123-456-7890', valid: true },
        { input: 'not-a-phone', valid: false },
        { input: '<script>555-1234</script>', valid: false }
      ];
      
      const phoneRegex = /^\+?[\d-]{10,}$/;
      
      testCases.forEach(({ input, valid }) => {
        const sanitized = DOMPurify.sanitize(input);
        const isValid = phoneRegex.test(sanitized);
        expect(isValid).toBe(valid);
      });
    });
    
    it('validates and sanitizes URLs', () => {
      const testCases = [
        { input: 'https://example.com', valid: true },
        { input: 'javascript:alert("xss")', valid: false },
        { input: 'data:text/html,<script>alert("xss")</script>', valid: false },
        { input: 'http://legitimate-site.com', valid: true }
      ];
      
      testCases.forEach(({ input, valid }) => {
        const sanitized = DOMPurify.sanitize(input);
        const url = valid ? new URL(sanitized) : null;
        
        if (valid) {
          expect(url?.protocol).toMatch(/^https?:$/);
        } else {
          expect(() => new URL(sanitized)).toThrow();
        }
      });
    });
  });
  
  describe('File Upload Security', () => {
    it('validates file types and sizes', async () => {
      const testCases = [
        { 
          file: new File(['test'], 'test.pdf', { type: 'application/pdf' }),
          valid: true 
        },
        { 
          file: new File(['test'], 'malicious.exe', { type: 'application/x-msdownload' }),
          valid: false 
        },
        { 
          file: new File(['test'], 'large.pdf', { type: 'application/pdf' }),
          size: 11 * 1024 * 1024, // 11MB
          valid: false 
        }
      ];
      
      const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png'];
      const maxSize = 10 * 1024 * 1024; // 10MB
      
      testCases.forEach(({ file, valid }) => {
        const isValidType = allowedTypes.includes(file.type);
        const isValidSize = file.size <= maxSize;
        
        expect(isValidType && isValidSize).toBe(valid);
      });
    });
  });
}); 